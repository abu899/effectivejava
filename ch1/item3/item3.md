# Item 3

## 생성자나 열거 타입으로 싱글턴임을 보장하라

### 첫 번째 방법

- private 생성자 + public static final 필드
- 장점
  - 간결하고 싱글턴임을 API 에 드러낼 수 있음
- 단점
  - 싱글턴을 사용하는 클라이언트 테스트를 하기가 어려움
    - 인터페이스가 없는 경우 항상 직접 호출해야함
    - 하지만, 대상이 많은 시간이 걸리거나 외부 네트워크를 타야하는 경우 비용이 증가
  - 리플렉션으로 private 생성자를 호출 가능
    - 즉, 싱글턴이 깨지게됨
  - 역질렬화 할 때, 새로운 인스턴스가 생길 수 있음

### 두 번째 방법

- private 생성자 + 정적 팩터리 메서드
  - 장점
    - API 를 바꾸지 않고도 싱글턴이 아니게 변경 가능
    - 정적 팩터리를 제네릭 싱글턴 팩터리로 만들 수 있음
    - 정적 팩터리의 메서드 참조를 `Supplier`로 사용 가능
  - 단점
    - 첫 번째 방법과 동일

### 세 번째 방법

- 열거 타입
- 가장 간결한 방법이며 직렬화와 리플렉션에도 안전
- 대부분의 상황에서는 원소가 하나 뿐인 열거 타입이 승글턴을 만드는 가장 좋은 방법

## 완벽공략

- 리플렉션 API 로 private 생성자 호출하기
- 메서드 참조를 공급자로 사용할 수 있음
- Supplier<T>, 함수형 인터페이스
- 직렬화, 역직렬화, Serializable, transient

### 메서드 참조

- 메소드 하나만 호출하는 람다 표현식을 줄여서 쓰는 방법
- 스테틱 메서드 레퍼런스
- 인스턴스 메서드 레퍼런스
- 임의 객체의 인스턴스 메서드 레퍼런스
- 생성자 레퍼런스

### 함수형 인터페이스

- 함수형 인터페이스는 람다 표현식과 메서드 참조에 대한 `Target Type`을 제공
  - 타겟 타입은 변수 할당, 메서드 호출, 타입 변환에 활용
  - 자바에서 제공하는 기본 함수형 인터페이스를 파악하자
    - java.util.function
- 함수형 인터페이스를 만들어 사용 가능

### 직렬화

- 객체를 Byte Stream 으로 상호 변환하는 기술
  - Byte Stream 으로 변환한 객체를 파일 또는 네트워크를 통해 전달 가능
- Serializable 인터페이스 구현 필요
  - transient 를 사용해서 직렬화 하지 않을 필드를 선언할 수 있음
- `serialVersionUID`는 언제 사용하는가?
  - serialVersionUID 가 같으면 객체가 변경되어도 역직렬화가 가능
  - 즉, 객체 변경에 민감하지 않게 유연하게 직렬화, 역직렬화를 하려면 직접 serialVersionUID 를 관리