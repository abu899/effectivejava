# Item 17

## 변경 가능성을 최소화 하라

- 불변 클래스는 가변 클래스보다 설계, 구현, 사용이 쉬우며 오류가 생길 여지가 적고 안전
- 불변 클래스를 만드는 다섯가지 규칙
  - 객체의 상태를 변경하는 메서드를 제공하지 않음
  - 클래스를 확장할 수 없도록 함
  - 모든 필드를 final
    - final 을 적용할 수 있는 곳에서는 최대한 적용하는게 성능적인 이득 또한 존재
  - 모든 필드를 private 으로 선언
  - 자신 외에는 내부의 가변 컴포넌트에 접근할 수 없음
    - part1.Person 의 예제처럼 Address 를 받아서 생성하는 Person 은 Address 에 의해 내부 정보가 바뀜
    - Address 가 final 이지만 reference 가 final 이지 내부 정보가 final 은 아님
    - 즉, 가변 컴포넌트에 대해서는 방어적인 복사로 제공

### 불변 클래스의 장단점

- 장점
  - 함수형 프로그래밍에 적합
    - 피연산자에 함수를 적용한 결과를 반환하지만 피연산자가 바뀌진 않음
  - 불변객체는 단순
  - 불변객체는 근본적으로 Thread-safe 이므로, 동기화 불필요
    - Thread-safe 의 가장 중요한 문제는 여러 쓰레드에서 한 인스턴스의 값을 서로 바꾸는 경우
    - 하지만, 불변객체는 인스턴스의 애초에 값을 바꿀 수 없기에 Thread-safe
  - 불변객체는 안심하고 공유 가능
    - 상수, public static final
    - BigInteger 의 예, negate()
  - 불변객체 끼리 내부 데이터를 공유 가능
  - 객체를 만들 때 불변객체로 구성하면 이점이 많음
    - Set 같은 경우 내부 데이터가 변경되면 깨질 위험이 존재하지만 불변객체는 그럴 위험이 없음
  - 실패 원자성 제공
    - 어떤 연산이 실패하더라도 원래 데이터가 변경되지 않음
- 단점
  - 값이 다르다면 반드시 별도의 객체로 만들어야함
    - 인스턴스를 생성하는 비용이 작다면 전혀 문제되지 않겠지만 큰 경우 
    - `다단계 연산`을 제공하거나 `가변 동반 클래스`를 제공해 대처 가능
      - 여러 연산을 하나로 묶어서 제공하는 것이 `다단계 연산`
        - 여러 연산에서 생성되는 인스턴스를 하나로 할 수 있음
      - 가변 동반 클래스
        - StringBuilder

### 불변 클래스를 만들 때 고려할 것

- 상속을 막을 수 있는 또 다른 방법
  - private 또는 package-private 생성자 + 정적 팩토리 메서드
    - 사실상 final 클래스(Effective final class)
  - 확장이 가능
    - 다수의 package-private 구현 클래스를 만들 수 있음
  - 정적 팩터리를 통해 여러 구현 클래스 중 하나를 활용할 수 있는 유연성 제공
    - 상속이 불가능하지만 클래스 내부에서는 얼마든지 상속이 가능하기에 내부에서 상속된 어떤 클래스를 정적 팩터리 메서드를 통해 제공 가능한 유연성
  - 자주 쓰이는 값이라면 객체 캐싱 기능으로 성능을 향상
- 재정의가 가능한 클래스는 방어적인 복사를 사용
- 모든 외부에 공개하는 필드가 `final`이여야 함
  - 계산 비용이 큰 값은 해당 값이 필요할 때 계산(lazy)하여 final 이 아닌 필드에 캐시해서 쓸 수 있음

## 완벽 공략

- 새로 생성된 불변 인스턴스를 동기화 없이 다른 쓰레드로 건네도 문제없이 동작(JLS 17.5)
- readObject 메서드에서 `방어적 복사`를 수행하자
  - Serialization
- 불변 클래스의 내부에 가변 객체를 참조하는 필드가 있다면 방어적 복사를 수행하자
- java.util.concurrent 패키지의 `CountDownLatch`

### final 과 자바 메모리 모델(Java Memory Model, JMM)

- final 을 사용하면 `안전하게 초기화`할 수 있다
  - final 은 스펙상, 오로지 인스턴스에 해당하는 필드가 초기화 된 이후에만 해당하는 인스턴스를 다른 쓰레드가 사용
- JMM
  - JMM 은 JVM 의 메모리 구조가 아님
  - 한 쓰레드 내에서 적법한 프로그램의 실행 규칙
    - 어떻게 프로그램을 실행해야 legal 한 프로그램 실행인 것인가?
  - 메모리 모델이 허용하는 범위내에서 프로그램을 어떻게 실행하든 구현체(JVM)의 자유
    - 이 과정에서 실행 순서가 바뀔 수 있음
    - 즉 우리가 의도한 실행순서가 아니라 JVM 에 의해 실행 순서가 바뀔 수 있음
- 어떤 인스턴스의 final 변수를 초기화 하기 전까지 해당 인스턴스를 참조하는 모든 쓰레드는 기다려야함(Freeze)
- JMM 과 final 을 완벽히 이해하려면 JLS(Java Language Specification) 17.4와 17.5 참고

### java.util.concurrent 패키지

- 병행 프로그래밍에 유용하게 사용할 수 있는 유틸리티 묶음
- 병행(concurrency)은 여러 작업을 번갈아가며 실행해 마치 동시에 여러작업을 동시에 처리하듯 보임
  - 하지만 실제로는 한번에 오직 한작업만 실행
  - 즉, CPU 가 한개여도 가능
- 병렬(parallel)은 여러 작업을 동시에 처리
  - CPU 가 여러개 있어야 가능
- concurrent 패키지는 이에 대한 다양한 툴을 제공
  - BlockingQueue, Callable, ConcurrentMap, Executor, ExecutorService, Future...

### CountdownLatch

- 다른 여러 쓰레드로 실행하는 여러 오퍼레이션이 마칠 떄 까지 기다릴 때 사용할 수 있는 유틸리티
- 초기화 할 떄 숫자를 입력하고 await() 메서드를 사용해 숫자가 0이 될떄까지 기다림
  - 숫자를 셀 떄는 countDown() 메서드를 사용
- 재사용할 수 있는 인스턴스가 아님
  - 숫자를 리셋해서 재사용하려면 `CyclicBarrier`를 사용해야 함
- 시작 또는 종료 신호로 사용 가능