# Item 10

## equals 는 일반규약을 지켜 재정의하라

- equals 를 만들지 않아도 되면 재정의 하지 않는 것이 최선
- 다음의 경우에는 equals 를 재정의 할 필요가 없음
  - 각 인스턴스가 본질적으로 고유
    - 싱글턴 클래스나 Enum 같은 경우
  - 인스턴스의 `논리적 동치성`을 검사할 필요가 없음
  - 상위 클래스에서 재정의한 equals 가 하위 클래스에도 적절
    - List 나 Set 같은 걸 상속받아 만드는 경우
  - 클래스가 private 이거나 package-private 이고 equals 메서드를 호출할 일이 없음
    - public class 의 경우 equals 가 호출되지 않는다고 보장하기 어려움

## Equals 규약

### 반사성

`A.equals(A) == true`

- 본인이 본인이랑 비교했을 때 같아야함
  - this == obj

### 대칭성

`A.equals(B) == B.equals(A)`

- A == B, B == A
- A != B, B != A

### 추이성

`A.equals(B) & B.equals(C), A.equals(C)`

- A == B, B == C, A == C
- 자식 클래스가 필드를 추가하게되면 추이성이나 대칭성을 위반하지 않는 equals 를 추가하는 방법은 존재하지 않음
  - 그럴 땐, 상속이 아닌 Composition 을 사용하자

### 일관성

`A.equals(B) == A.equals(B)`

- 객체 내의 있는 값이 바뀌게 되면 일관성이 깨질 순 있음
- 단, 불변객체의 경우 항상 일관성이 보장됨
- 불변객체냐 가변객체냐에 따라 일관성은 달라질 수 있음

### null

`A.equals(null) == false`

### 그럼 어떻게 구현해야할까?

1. `==` 연산자를 사용해 자기 자신의 참조인지 확인
2. `instanceof` 연산자로 올바른 타입인지 확인
3. 입력된 값을 올바른 타입으로 형변환
4. 입력 객체와 자기 자신에 대응되는 `핵심 필드가 일치`하는지 확인
   - float 이나 double 처럼 부동소수점에 영향을 받는 변수들은 `compare`를 통해 비교
   - primitive 타입은 == 로 비교
   - reference 타입은 equals 로 비교
   - null 이 들어와도 된다면 Objects.equals() 를 사용

- Lombok 사용하자
  - 사실 이런 규약을 따르면서 구현하기 쉽지 않기에 툴을 사용해보자
- IDE 코드 생성기능 사용
- java Record 사용

## 주의사항

- equals 를 재정의할 때는 `반드시 hashCode`도 재정의 하자!
- 너무 복잡하게 해결하지 않기
  - 굳이 타겟같은 걸 계산하는 등
- Object 가 아닌 타입의 매개변수를 받는 equals 메서드는 선언하지 않아야 함
  - override 가 아니기에
  - 이렇게하면 논리적 동치성을 검사하지 않게 되버림
  - List 같은 곳에 넣게되면 결in국 Override equals 로 비교하게됨

## 완벽 공략

### Value 기반의 클래스

- 클래스처럼 생겼지만 int 처럼 동작하는 클래스
- 식별자가 없고 불변(immutable)
- 식별자가 아니라 인스턴스가 가지고 있는 상태를 기반으로 equals, hashCode, toString 구현
- `==`연산자가 아닌 equals 를 통해 동등성을 비교
- 동일한 객체는 상호교환이 가능

### StackOverflowError

- 로컬 변수와 객체가 저장되는 공간의 이름은?
  - Stack
- 스택과 힙
- 메소드 호출 시, 스택에 스택 프레임이 쌓인다
  - 스택 프레임에 들어가 있는 정보
    - 메소드에 전달하느 매개변수, return 되어 돌아갈 위치, 힙에 들어있는 객체에 대한 레퍼런스
  - 만약 스택 프레임을 쌓을 수 없다면?
    - StackOverflowError
- 스택의 사이즈를 조절하고 싶다면
  - `-Xss10M`

### 리스코프 치환 원칙

- 객체 지향 5대 원칙의 SOLID 중 L
- `하위 클래스의 객체가 상위 클래스 객체를 대체`하더라도 소프트웨어의 기능을 깨뜨리지 않아야 한다
  - 구분 보다는 의미