# Item 11

## equals 를 재정의하려거든 hashCode 도 재정의하라

- equals 에서 사용되는 필드들을 모두 사용해서 hashCode 를 계산해야 함
- equals 비교에 사용하는 정보가 변경되지 않았다면 hashCode 는 매번 같은 값을 리턴해야함
    - 변경되거나 어플리케이션을 다시 시작하면 달라지게됨
- `두 객체 대한 equals 가 같다면 hashCode 도 같아야함`
- 두 객체에 대한 equals 가 다르더라도 hashCode 는 같을 수 있지만, `해시테이블 성능을 고려해 다른 값을 리턴하는 것이 좋음`
  - O(1) 에서 O(n)으로 낮아짐
  - 같은 hasCode 로 인해, hash collision 으로 인해 hash bucket 의 object 를 linked list 로 만듦

## HashCode 구현 방법

- 전형적인 hashCode
   - 가장 핵심 필드 중 하나를 골라서 hashCode 값을 구함
   - 그 다음 필드부터는 위에서 얻은 값에 31을 곱하고 다음 필드의 해쉬값을 더함
     - 짝수를 쓰면 뒤에 0이 채워져서 숫자가 왼쪽으로 밀리게 됨
     - 홀수 중 왜 31인가
       - hashing 을 했을 때, 사전 내 단어를 가지고 가장 충돌이 적은 소수가 31이었음
     - 사실 홀수면 크게 상관이 없다고 함
- Objects 를 이용한 hashCode
  - Arrays.hashCode() 이용
    - 위의 방법과 비슷하게 구현되어 있음
- Guava
  - goodFastHash
    - 조금 더 빠르고 덜 충돌이 발생하는 hashing 방법
  - 굳이 해시코드 하나 생성하고자 라이브러리를 도입하는건 좀...
- 만약 hashCode 계산을 자주하고, 클래스가 불변 변수를 가지고 있다?
  - 필드에 hashCode 를 저장하고 재사용
    - Lazy-initialization
  - 멀티쓰레드 환경에서는 쓰레드 안정성을 신경써야함(Item 83)
    - 여러 개 쓰레드가 동시에 들어오게되면 hashCode 가 기대했던 값과 다른 상황이 발생할 수 있음

### 주의할 점

- 해시 알고리즘은 equals 에서 사용하는 모든 변수를 해시 알고리즘에 포함해야함
  - 즉, 3개를 사용하는데 2개만 가지고 만들면 안됨
- 해시 알고리즘을 굳이 외부에 노출할 필요가 없음

## 완벽 공략

- 연결 리스트
- 해시 충돌이 더욱 적은 방법이 꼭 쓰여져야한다면
- 쓰레드 안전하게 만들도록 신경써야함

### 해시맵 내부의 연결 리스트

- 내부 구현은 언제든지 바뀔 수 있음
- Java 8 에서 해시 충돌 시 성능 개선을 위해 내부적으로 동일한 버켓에 일정 갯수 이상의 엔트리가 추가되면, 연결리스트 대신 이진 트리를 사용하게 변경
- 연결 리스트에서 어떤 값을 찾는데 걸리는 시간
  - O(n)
- 이진 트리에서 어떤 값을 찾는데 걸리는 시간
  - O(logN)

### 쓰레드 안전

- 멀티 쓰레드 환경에서 안전한 코드
- 가장 안전한 방법은 여러 쓰레드 간에 공유하는 데이터가 없는 것
- 공유하는 데이터가 있다면
  - Synchronization
  - ThreadLocal
  - 불변 객체 사용
  - Concurrent 류 데이터 사용
  - ..etc