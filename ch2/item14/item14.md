# Item 14

## Comparable 을 구현할지 고민하라

- Object.equals 에 더해서 순서까지 비교할 수 있으며 Generic 을 지원
  - 컴파일 시점에 타입 체크가 가능
  - equals 와 비슷하지만, 순서 비교 및 Generic 지원
- 자기 자신(this)이 compareTo 에 전달된 객체보다 작으면 음수, 같으면 0, 크면 양수 리턴
  - 구현에 따라 리턴되는 값이 달라질 수 있으므로 특정 숫자에 의존하면 안됨
- 반사성, 대칭성, 추이성을 만족해야함
- 반드시 따라야하는건 아니지만 x.compareTo(y) == 0 이라면, x.equalsTo(y) 는 true 여야 함

### Comparable 구현 방법

- 자연적인 순서를 제공할 클래스에 Comparable<T> 를 implementation
- compareTo 메서드 재정의
  - 메서드 내에서 기본 타입은 박싱된 기본 타입의 compare 을 사용해서 비교
- 핵심 필드가 여러개라면 비교순서가 중요!
  - 순서를 결정하는데 가장 중요한 필드를 비교하고 그 값이 0 이면 이후 필드를 비교
- 기존 클래스를 확장하고 필드를 추가하는 경우 compareTo 규약을 지킬 수 없음
  - 즉 상위 클래스에서 compareTo 를 구현하고 하위 클래스에 필드가 추가된다면 compare 할 수가 없음
    - 별도의 Comparator 를 추가적으로 제공하는 방법이 존재하긴 함(추천하지 않음)
  - Composition 활용
    - layering 을 활용해서 상속 받은 클래스를 비교하고 이후에 고유한 필드를 비교
- Comparator 생성 메서드를 활용

## 완벽공략

- 제네릭 인터페이스이므로 compareTo 메서드의 인수타입은 `컴파일 타임`에 정해짐
- java 의 `타입 추론 능력`이 이 상황에서 타입을 알아 낼만큼
  - Comparator 생성 메서드의 처음에는 직접 타입선언을 해줬어야 함
  - 하지만 then 으로 이어지는 순간 타입을 선언해주지 않아도 알게 됨
- 이 방식은 `정수 오버플로`를 일으키거나
- IEEE 754 `부동 소수점 계산 방식`에 따른 오류를 낼 수 있음
  - 지수부, 가수부
  - 가수부를 이진수로 표현하다가 float 이나 double 이 표현할 수 있는 메모리 공간을 넘어서면 값이 잘리고 계산의 결과가 부정확해짐
  - 정확한 값을 계산해야하는 경우 Decimal 을 사용하자